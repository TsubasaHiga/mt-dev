#!/usr/bin/env perl

use strict;
use warnings;
use utf8;

use FindBin;
use lib "$FindBin::Bin/local/lib/perl5";

use Cwd qw(realpath);
use Data::Dumper;
use HTTP::Tiny;
use Config::Tiny;
use YAML::Tiny qw(LoadFile DumpFile);
use File::Spec::Functions qw(catfile);
use File::Temp qw(tempfile tmpnam);

my $recipe_dir    = realpath("$FindBin::Bin/../recipe");
my $repo_base_dir = realpath("$FindBin::Bin/../..");
my $git_clone_cmd = realpath("$FindBin::Bin/git-clone");

return unless @ARGV;

my $env   = {};
my $yamls = [];

for my $recipe (@ARGV) {
    my $recipe_file = "$recipe_dir/$recipe.yaml";

    # get recipe
    if ( realpath($recipe_file) !~ m/^$recipe_dir/ || !-e $recipe_file ) {
        $recipe_file = "";
        my $conf_file = catfile( $ENV{'HOME'}, '.mt-dev.conf' );

        my $conf = Config::Tiny->read( $conf_file, 'utf8' );
        if ( !$conf ) {
            $conf = Config::Tiny->new;

            print STDERR "Please input base URL of recipe data: ";
            my $base = <STDIN>;
            chomp $base;

            $conf->{recipe}{base_url} = $base;
            $conf->write( $conf_file, 'utf8' );
        }

        if ( $conf->{recipe}{base_url} ) {
            my $base_url = $conf->{recipe}{base_url};
            $base_url =~ s/\/+$//;
            my $response = HTTP::Tiny->new->get("$base_url/$recipe.yaml");
            die "Failed: @{[Dumper($response)]}"
                unless $response->{success} && length $response->{content};

            my ( $fh, $filename ) = tempfile();
            print $fh $response->{content};

            $recipe_file = $filename;
        }

        if ( !$recipe_file ) {
            die qq{Can not find recipe for "$recipe".};
        }
    }

    my $data = LoadFile($recipe_file);

    # detect docker images
    if ( my $perl = delete $data->{perl} ) {
        $env->{DOCKER_MT_IMAGE} = "movabletype/dev:perl-$perl";
    }
    if ( my $mysql = delete $data->{database} ) {
        $env->{DOCKER_MYSQL_IMAGE} = $mysql;
    }
    if ( my $php = delete $data->{php} ) {
        $env->{DOCKER_HTTPD_IMAGE} = "movabletype/dev:php-$php";
    }

    # checout branch and collect links
    my @volumes;
    for my $k ( keys %$data ) {
        my $repo     = $data->{$k}{location};
        my $dest_dir = $data->{$k}{directory} || do {
            ( my $dir = $repo ) =~ s{.*/}{};
            "$repo_base_dir/$dir";
        };
        if ( $dest_dir !~ m{\A/} ) {
            $dest_dir = "$repo_base_dir/$dest_dir";
        }

        if ( $k eq 'core' ) {
            $env->{MT_HOME_PATH} = $dest_dir;
        }

        if ($repo) {
            my $cmd
                = "$git_clone_cmd $repo $dest_dir @{[$data->{$k}{branch} || '']}";
            my $res = `$cmd 2>&1` || "";
            die "$res\nGot an error: $cmd" if $?;

            $res = `cd $dest_dir && git rev-parse HEAD 2>&1`;
            die "$res\nGot an error: git rev-parse HEAD" if $?;
            print STDERR "$k:$res";
        }

        next if $k eq 'core';

        my $links = $data->{$k}{links};
        if ( !$links ) {
            $links = [
                map { $_ =~ s{\A$dest_dir/}{}; $_ } (
                    glob("$dest_dir/*.cgi"),
                    glob("$dest_dir/plugins/*"),
                    glob("$dest_dir/mt-static/plugins/*"),
                )
            ];
        }

        for my $l (@$links) {
            push @volumes, "      - '$dest_dir/$l:/var/www/cgi-bin/mt/$l'";
        }
    }

    my ( $fh, $file ) = tmpnam();
    print $fh <<YAML;
version: "3"
services:
  mt:
    volumes:
@{[join "\n", @volumes]}
  httpd:
    volumes:
@{[join "\n", @volumes]}
YAML
    close $fh;

    push @$yamls, $file;
}

if (@$yamls) {
    $env->{DOCKER_COMPOSE_YML_OVERRIDE} = join( ' ', map {"-f $_"} @$yamls );
}

# output args for make command
print join ' ', map {qq{$_="@{[$env->{$_}]}"}}
    keys(%$env);
